##################################  시험 관련  #################################
# 스택은 선형구조
# 미로찾기까지 시험범위
# 손코딩은 없음
# 프로그램 구현 x

# 1장 알고리즘 시간 복잡도 빅 오로 표기 하는 것 중 빠른 순서, 우선순위 구분
# 알고리즘 시간복잡도 계산시 for 문이 도는 동안 for 문 안에 연산을 할 경우
# 시간복잡도가 얼마나 걸리는 건지, 이것을 빅 오로 표현 하는 방법

# 3장 리스트
# 자료구조 리스트에 대해 객관식 및 단답형으로 출제
# 자료구조 리스트 구현 기법인 연결 리스트중, 단순 연결리스트, 이중 연결리스트, 원형 연결리스트에
# 대한 개념을 질문
# 의사코드로 기술된 소스코드를 보고 답하는 문제가 출제되므로, 자료구조 리스트를 연결 리스트로
# 구현하는 소스코드 공부 (객관식, 단답형)

# 알고리즘
# 재귀알고리즘시 재귀호출로 변환 하는 방법, 반복문을 순환구조로 변환 하는 법 (1~2문제)
# 재귀알고리즘 이론적으로 물어봄, 어느게 순환구조로 적합한가(객관식)

# 스택
# 스택에서 괄호검사시 수식을 읽어들이는 중 저장된 진행과정을 그림으로 도식화 한것
# 중위에서 후위 표기(주관식 혹은 객관식으로 나옴)
# 후위표기 수식을 스택으로 구현했음 -> 스택에 저장된 것이 무엇이냐
# 스택을 구연할 때 push 와 pop 에 따른 stack 의 상황
# 스택을 기반으로 출력 가능한 경우의 수 를 알아야 한다.
# 설명이나 증명하라 는 안냄

# 이해한 것을 표현할 수 있으면 된다. 짧게, 의미가 포함되어 있으면 된다.

# 구현 x
# 구현중 한줄정도는 빈칸으로 낼 수 있음

# 구현기법
# 배열, 리스트

# 리스트는 이론만
# 구현까진 안해도 됨, 이론만 알기
# 장단점 등

##############################################################################

# 1장
# 자료구조란
# 일상생활에서 사물의 조직화

# 선형자료구조
# 항목들을 순서적으로 나열해 저장
# 항목 접근 방법에 따라 세분화
# 리스트: 가장 자유로운 선형 자료구조
# 스택, 큐, 덱: 항목의 접근이 맨 앞이나 맨 뒤로 제한됨

# 비선형 자료구조
# 항목들이 복잡한 연결 관계를 가짐
# 트리: 회사의 조직도나 컴퓨터의 폴더와 같은 계층 구조(힙 트리, 이진 탐색트리, AVL 트리)
# 그래프: 가장 복잡한 연결 관계를 표현
# - 다영한 문제를 해결하기 위한 기본구조로 사용됨

# 알고리즘이란
# 컴퓨터로 문제를 풀기 위한 단계적 절차
# 프로그램 = 자료구조 + 알고리즘

# 알고리즘의 조건
# 입력: 0개 이상의 입력이 존재해야 한다.
# 출력: 1개 이상의 출력이 존재해야 한다.
# 명백성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
# 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다.
# 유효성: 각 명령어들은 실행 가능한 연산이어야 한다.

# 추상 자료형(ADT)
# 프로그래머가 추상적으로 정의한 자료형으로 데이터나 연산이 무엇인가는 정의되지만
# 데이터나 연산을 어떻게 컴퓨터 상에서 구현할 것인지는 정의되지 않는다.
# 예를 들면 turtle 모듈의 turtle.forward(100)은 터틀이 100만큼 앞으로 간다는 것을
# 알지만 이가 어떻게 구현되고 있는지는 알 수 없다.

# 추상데이터 타입 정의
# 객체: 추상 데이터 타입에 속하는 객체가 정의
# 연산: 이들 객체들 사이의 연산이 정의됨, 이 연산은 추상 데이터타입과 외부를 연결하는
# 인터페이스의 역할을 한다.

# 알고리즘의 성능분석
# - 실행시간을 측정하는 방법
# 알고리즘을 구현한 프로그램을 컴퓨터에서 실행시켜 시행완료까지 소요된 시간을 측정
# 실제 측정된 시간으로 알고리즘의 성능을 객관적으로 평가하는 데는 한계가 존재
# 프로그래머의 숙련도, 구현에 사용된 프로그래밍 언어의 종류, 알고리즘을 실행한 컴퓨터의
# 성능에 따라 수행시간은 달라질 수 있기 때문이다.

# 알고리즘의 복잡도 계산
# 직접 구현하지 않고 수행시간을 분석
# 알고리즘이 수행하는 연산의 횟수를 측정 비교
# 시간 복잡도 분석: 수행 시간 분석
# 공간 복잡도 분석: 수행시 필요로 하는 메모리 공간 분석


# 빅오 표기법
# 함수의 상한을 표시 (최악의 경우에서 가장 효율적인것을 찾음)
# 상수형이 가장 효율적이며, 지수령, 팩토리얼형이 가장 비효율적이다.

# 빅오메가 표기법
# 함수의 하한을 표시 (최선의 경우에서 가장 효율적인 것을 찾음)

# 빅세타 표기법
# 함수의 하한과 상한을 표시

# 최선의 경우: 의미가 없는 경우가 많다.
# 평균적인 경우: 계산하기가 상당히 어렵다.
# 최악의 경우: 가장 널리 사용되며, 계산하기 쉽고 응용에 따라 중요한 의미를 가질 수 있다.


# 3강 리스트
# 시험
# 자료구조 리스트에 대해 객관식 및 단답형으로 출제
# 자료구조 리스트 구현 기법인 연결 리스트중, 단순 연결리스트, 이중 연결리스트, 원형 연결리스트에
# 대한 개념을 질문
# 의사코드로 기술된 소스코드를 보고 답하는 문제가 출제되무로, 자료구조 리스트를 연결 리스트로
# 구현하는 소스코드 공부 (객관식, 단답형)

# 일반적인 리스트는 동일한 타입의 항목들이다.
# 학생명단, 시험성적, 서점의 신간 서적, 상점의 판매 품목, 실시간 급상승 검색어, 버킷 리스트

# 일반적인 리스트의 구현
# - 1차원 파이썬 리스트
# - 단순연결리스트
# - 이중연결리스트
# - 원형연결리스트

# 리스트의 구조
# 항목들이 순서대로 나열되어 있으며 각 항목들은 인덱스를 가진다.

# 리스트 구현 방법
# 배열구조:
# - 구현이 간단, 항목접근이 O(1), 삽입 삭제시 오버헤드, 항목의 개수 제한

# 연결된 구조:
# - 구현이 복잡, 항목접근이 O(n), 삽입 삭제가 효율적, 크기가 제한되지 않음

# 파이썬 리스트(배열구조)
# 동적으로 구현되어 있음
# 용량증가시 기존 배열 용량의 2배로 한 뒤, 기존 배열을 복사, 항목을 삽입 하는 과정으로 이루어 진다.

# 시간복잡도
# append(e): 대부분의 경우 O(1)
# insert(pos,e): O(n)
# pop(pos): O(n)

# 연결구조
# 용량이 고정되어 있지 않다.
# 중간에 자료를 삽입하거나 삭제하는 데 용이하다. O(n)


# 단순연결리스트(연결구조)
# 동적 메모리 할당 받아 노드를 저장하고 노드는 레퍼런스를 이용해 다음 노드를 가리키도록 만든다.
# 이를 한 줄로 연결시킨다.

# 삽입이나 삭제 시 항목들의 이동이 필요 없다.
# 배열의 경우 배열의 크기를 설정해 빈공간을 가지나, 연결리스트는 빈공간이 존재하지 않는다.
# 항목 탐색시 첫 노드부터 원하는 노드까지 차례로 방문하는 순차탐색을 해야한다.

# 활용
# 스택, 큐
# 해싱의 체이닝에 사용
# 트리도 단순연결리스트의 개념을 확장시킨 자료구조

# 수행시간
# search()는 탐색을 위해 연결리스트의 노드들을 첫 노드부터 순차적으로 방문해야 하므로
# O(n) 시간 소요


# 이중연결리스트
# 각 노드가 두 개의 레퍼런스를 가지고 각각 이전노드와 다음 노드를 가리키는 연결리스트
# 단순연결리스트는 삽입, 삭제 시 이전 이전 노드를 가리키는 레퍼런스를 추가로 알아내야 하고
# 역방향으로 노드를 탐색할 수 없다.
# 이러한 단점을 보완하나, 노드마다 두개의 레퍼런스를 가진다는 단점이 있다.

# 활용
# 이중연결리스트는 데크(Deque) 자료구조를 구현하는데 사용
# 이항힙이나 피보나치힙과 같은 우선순위 큐를 구현하는 데에도 이중연결리스트가 부분적으로 사용

# 수행시간
# 삽입, 삭제 연산은 각각 상수개의 레퍼런스만을 갱신
# O(1)
# 탐색 연산: head or tail 부터 노드를 순차적으로 탐색해야 하므로
# O(N)



# 5주차 스택
# 한쪽 끝에서만 항목을 삭제, 저장 하는 자료구조
# 새 item 을 저장하는 연산: push
# Top item 을 삭제하는 연산: pop
# 후입 선출원칙 하에 item 의 삽입과 삭제를 수행한다.

# 스택 ADT
# 데이터: 후입선출의 접근 방법을 유지하는 항목들의 모음
# 연산:
# Stack(): 비어있는 새로운 스택을 만든다.
# isEmpty(): 스택이 비어있으면 True 를 아니면 False 를 반환한다.
# push(e): 항목 e 를 스택의 맨 위에 추가한다.
# pop(): 스택의 맨 위에 있는 항목을 꺼내 반환한다.
# peek(): 스택의 맨 위에 있는 항목을 삭제하지 않고 반환한다.
# size(): 스택내의 모든 항목들의 개수를 반환한다.
# clear(): 스택을 공백상태로 만든다.

# 스택의 용도
# 되돌리기
# 함수호출
# 괄호검사
# 계산기: 후위 표기식 계산, 중위 표기식의 후위 표기식 변환
# 미로탐색 등

# 수행시간
# 파이썬의 리스트로 구현한 스택의 push 와 pop 연산은 각각 O(1)시간이 소요
# 파이썬의 리스트는 크기가 동적으로 확대, 축소되며, 이러한 크기 조절은 사용자도
# 모르게 수행된다. 따라서 스택의 모든 항목들을 새 리스트로 복사해야 하기 때문에
# O(N)시간이 소요된다.


# def hanoi_tower(n, A, B, C):
#     if n == 1:
#         print('원판 1: %s --> %s' % (A, C))
#     else:
#         hanoi_tower(n-1, A, C, B) # a -> c
#         print('원판 %d: %s --> %s' % (n, A, C))
#         hanoi_tower(n-1, B, A, C)
#
#
# hanoi_tower(10, 'A', 'B', 'C')




# 단순연결리스트
# 동적메모리에 노드를 저장하고 노드는 다음 노드를 가리키는 레퍼런스를 가진다,
# 이를 한줄로 연결한 것을 단순 연결 리스트라 한다.
# - 삽입, 삭제시 항목들의 이동이 필요 없다.
# - 단, 탐색을 할 경우 첫 노드부터 원하는 노드까지 순차탐색을 진행해야 한다.
# - 배열과 달리 빈 저장공간이 존재하지 않는다.
#
# 이중 연결 리스트
# 노드가 두개의 레퍼런스를 가지고 각각 앞뒤의 노드를 가리키는 연결리스트이다.
# - 단순연결리스트는 삭제, 삽입시 반드시 이전 노드를 가리키는 래퍼런스를 알아내야 하지만
# 이중연결 리스트는 그렇지 않으며
# - 역방향으로도 노드를 탐색 할 수 있다.
#
# 원형 연결리스트
# 마지막 노드와 첫 노드가 연결된 단순연결리스트이다. 마지막
# - 노드와 첫번째 노드를 O(1)시간에 방문할 수 잇다.
# - 어떤 노드도 None 레퍼런스를 가지지 않으므로 프로그램에서 None 조건을
# 검사하지 않아도 된다.













