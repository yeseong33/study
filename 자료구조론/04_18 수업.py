# 회문검사하기

# 전반부의 문자들을 스택에 push한 후, 후반부의 각 문자를 차례로 pop한 문자와 비교한다.

# 스트링의 길이를 홀수, 짝수의 조건에 따라 조건을 다르게 해 이용할 수 있다.

# 짝수 일때 스택에 스트링 반을 넣고 그 이후 비교해 가며 회문한다.

# 홀수 일떼 반으로 나누어 가운데 스트링은 버리고 나머지를 짝수와 같이 비교한다.


# # 방법 1
# def is_palindrome(input_string):
#     token_list = list(input_string)
#
#     flag = True
#
#     while len(token_list) > 1 and flag == True:
#         # 만약 가운데 한글자가 남았다면 첫번째 조건을 만족하지 않으므로  flag가 True인 상태로
#         # while 문을 빠져 나간다.
#         first_char = token_list.pop(0)
#         last_char = token_list.pop(-1)
#         if first_char != last_char:
#             flag = False
#
#     return flag
#
#
# print(is_palindrome('racecar'))
# print(is_palindrome('raddar'))
# print(is_palindrome('wasitacatisaw'))
# print(is_palindrome('racecar'))
#
#
# # 방법 2
# def is_palindrome(input_string):
#     token_list = list(input_string)
#     stack = []
#     flag = True
#     if len(token_list) % 2 == 1:
#         del token_list[len(token_list)//2]
#
#     for i in range(len(token_list)):
#         if i < len(token_list)//2 :
#             stack.append(token_list[i])
#         else:
#             first_char = stack.pop()
#             last_char = token_list[i]
#
#             if first_char != last_char:
#
#                 flag = False
#     return flag
#
#
# print(is_palindrome('racecar'))
# print(is_palindrome('raddar'))
# print(is_palindrome('wasitacatisaw'))
# print(is_palindrome('racecar'))


# 수식의 표기법

# 중위표기법: A-B*C 처럼 흔히 알고 있는 표기법

# 후위표기법: A B +
# 컴파일러는 중위표기법 수식을 후위표기법으로 바꾼다.(후위표기법 수식은 괄호 없이 중위표기법 수식을
# 표현할 수 있다.)

# 전위표기법 연산자를 피연사자들 앞에 두는 표기법


# 표기법의 순서는 무조건 왼쪽부터

# 연산자 변위
# 피연산자의 위치는 바뀌면 안된다.

# 변환시 두개의 피연산자와 연산자 하나를 하나의 새로운 피연산자로 생각하면 쉽다.

# 후위 오른쪽으로
# 전위 왼쪽으로


# def R(input_string):
#     token_list = list(input_string)
#     stack = []
#     flag = True
#
#     for i in token_list:
#         if i == '+':
#             op = int(stack.pop()) + int(stack.pop())
#         elif i == '-':
#             op = int(stack.pop()) - int(stack.pop())
#         elif

##################################  시험 관련  #################################
# 스택은 선형구조
# 미로찾기까지 시험범위
# 손코딩은 없음
# 프로그램 구현 x
# 1장 알고리즘 시간 복잡도 빅 오로 표기 하는 것 중 빠른 순서, 우선순위 구분
# 알고리즘 시간복잡도 계산시 for 문이 도는 동안 for문 안에 연산을 할 경우
# 시간복잡도가 얼마나 걸리는 건지, 이것을 빅 오로 표현 하는 방법

# 재귀알고리즘시 재귀호출로 변환 하는 방법, 반복문을 순환구조로 변환 하는 법 (1~2문제)
# 재귀알고리즘 이론적으로 물어봄, 어느게 순환구조로 적합한가(객관식)

# 스택에서 괄호검사시 수식을 읽어들이는 중 저장된 진행과정을 그림으로 도식화 한것
# 중위에서 후위 표기(주관식 혹은 객관식으로 나옴)
# 후위표기 수식을 스택으로 구현했음 -> 스택에 저장된 것이 무엇이냐
# 스택을 구연할 때 push와 pop에 따른 stack의 상황

# 스택을 기반으로 출력 가능한 경우의 수 를 알아야 한다.
# 설명이나 증명하라 는 안냄

# 이해한 것을 표현할 수 있으면 된다. 짧게, 의미가 포함되어 있으면 된다.

# 구현 x
# 구현중 한줄정도는 빈칸으로 낼 수 있음

# 구현기법
# 배열, 리스트

# 리스트는 이론만
# 구현까진 안해도 됨, 이론만 알기
# 장단점 등 

##############################################################################

# 1장
# 자료구조란
# 일상생활에서 사물의 조직화

# 선형자료구조
# 항목들을 순서적으로 나열해 저장
# 항목 접근 방법에 따라 세분화
# 리스트: 가장 자유로운 선형 자료구조
# 스택, 큐, 덱: 항목의 접근이 맨 앞이나 맨 뒤로 제한됨

# 비선형 자료구조
# 항목들이 복잡한 연결 관계를 가짐
# 트리: 회사의 조직도나 컴퓨터의 폴더와 같은 계층 구조(힙 트리, 이진 탐색트리, AVL트리)
# 그래프: 가장 복잡한 연결 관계를 표현
# - 다영한 문제를 해결하기 위한 기본구조로 사용됨

# 알고리즘이란
# 컴퓨터로 문제를 풀기 위한 단계적 절차
# 프로그램 = 자료구조 + 알고리즘

# 알고리즘의 조건
# 입력: 0개 이상의 입력이 존재해야 한다.
# 출력: 1개 이상의 출력이 존재해야 한다.
# 명백성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
# 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다.
# 유효성: 각 명령어들은 실행 가능한 연산이어야 한다.

# 추상 자료형(ADT)
# 프로그래머가 추상적으로 정의한 자료형으로 데이터나 연산이 무엇인가는 정의되지만
# 데이터나 연산을 어떻게 컴퓨터 상에서 구현할 것인지는 정의되지 않는다.
# 예를 들면 turtle모듈의 turtle.foward(100)은 터틀이 100만큼 앞으로 간다는 것을
# 알지만 이가 어떻게 구현되고 있는지는 알 수 없다.

# 추상데이터 타입 정의
# 객체: 추상 데이터 타입에 속하는 객체가 정의
# 연산: 이들 객체들 사이의 연산이 정의됨, 이 연산은 추상 데이터타입과 외부를 연결하는
# 인터페이스의 역할을 한다.

# 알고리즘의 성능분석
# - 실행시간을 측정하는 방법
# 알고리즘을 구현한 프로그램을 컴퓨터에서 실행시켜 시행완료까지 소요된 시간을 측정
# 실제 측정된 시간으로 알고리즘의 성능을 객관적으로 평가하는 데는 한계가 존재
# 프로그래머의 숙련도, 구현에 사용된 프로그래밍 언어의 종류, 알고리즘을 실행한 컴퓨터의
# 성능에 따라 수행시간은 달라질 수 있기 때문이다.

# 알고리즘의 복잡도 계산
# 직접 구현하지 않고 수행시간을 분석
# 알고리즘이 수행하는 연산의 횟수를 측정 비교
# 시간 복잡도 분석: 수행 시간 분석
# 공간 복잡도 분석: 수행시 필요로 하는 메모리 공간 분석


# 빅오 표기법
# 함수의 상한을 표시 (최악의 경우에서 가장 효율적인것을 찾음)
# 상수형이 가장 효율적이며, 지수령, 팩토리얼형이 가장 비효율적이다.

# 빅오메가 표기법
# 함수의 하한을 표시 (최선의 경우에서 가장 효율적인 것을 찾음)

# 빅세타 표기법
# 함수의 하한과 상한을 표시

# 최선의 경우: 의미가 없는 경우가 많다.
# 평균적인 경우: 계산하기가 상당히 어렵다.
# 최악의 경우: 가장 널리 사용되며, 계산하기 쉽고 응용에 따라 중요한 의미를 가질 수 있다.


# 3강 리스트
# 시험
# 자료구조 리스트에 대해 객관식 및 단답형으로 출제
# 자료구조 리스트 구현 기법인 연결 리스트중, 단순 연결리스트, 이중 연결리스트, 원형 연결리스트에
# 대한 개념을 질문
# 의사코드로 기술된 소스코드를 보고 답하는 문제가 출제되무로, 자료구조 리스트를 연결 리스트로
# 구현하는 소스코드 공부 (객관식, 단답형)

# 일반적인 리스트는 동일한 타입의 항목들이다.
# 학생명단, 시험성적, 서점의 신간 서적, 상점의 판매 품목, 실시간 급상승 검색어, 버킷 리스트

# 일반적인 리스트의 구현
# - 1차원 파이썬 리스트
# - 단순연결리스트
# - 이중연결리스트
# - 원형연결리스트

# 리스트의 구조
# 항목들이 순서대로 나열되어 있으며 각 항목들은 인덱스를 가진다.

# 리스트 구현 방법
# 배열구조:
# - 구현이 간단, 항목접근이 O(1), 삽입 삭제시 오버헤드, 항목의 개수 제한

# 연결된 구조:
# - 구현이 복잡, 항목접근이 O(n), 삽입 삭제가 효율적, 크기가 제한되지 않음

# 파이썬 리스트(배열구조)
# 동적으로 구현되어 있음
# 용량증가시 기존 배열 용량의 2배로 한 뒤, 기존 배열을 복사, 항목을 삽입 하는 과정으로 이루어 진다.

# 시간복잡도
# append(e): 대부분의 경우 O(1)
# insert(pos,e): O(n)
# pop(pos): O(n)

# 연결구조
# 용량이 고정되어 있지 않다.
# 중간에 자료를 삽입하거나 삭제하는 데 용이하다. O(n)


# 단순연결리스트(연결구조)
# 동적 메모리 할당 받아 노드를 저장하고 노드는 레퍼런스를 이용해 다음 노드를 가리키도록 만든다.
# 이를 한 줄로 연결시킨다.

# 삽입이나 삭제 시 항목들의 이동이 필요 없다.
# 배열의 경우 배열의 크기를 설정해 빈공간을 가지나, 연결리스트는 빈공간이 존재하지 않는다.
# 항목 탐색시 첫 노드부터 원하는 노드까지 차례로 방문하는 순차탐색을 해야한다.


